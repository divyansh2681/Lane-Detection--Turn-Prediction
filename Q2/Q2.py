# -*- coding: utf-8 -*-
"""q2_lane_detection_iter1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15QtLtuLNPGwmaShslVMyxMAb2ZpcXhxi
"""

import numpy as np
import cv2

def image_cropping(img, vertices):
    # Define a blank matrix that matches the image height/width.
    mask = np.zeros_like(img)    
    black = (255,255,255)
    # Fill inside the polygon
    cv2.fillPoly(mask, vertices, black)
    # gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Returning the image only where mask pixels match
    masked_img = cv2.bitwise_and(mask, img)
    # masked_image = cv2.bitwise_and(mask, gray)
    return masked_img

def linelength(x1,y1,x2,y2):
    length = ((x1-x2)**2 + (y1-y2)**2)**0.5
    return length

def lineSlope(x1,y1,x2,y2):
    slope = (y2-y1)/(x2-x1)
    return slope

# classify lines as dashed or solid
def dash_or_solid(lines):
  max_length = 0
  max_p = []
  L = 0
  max_line_slope_sign = 0
  sign_all_slopes = 0

  for i in range(len(lines)): # this loop runs until a line with maximum length has been found
    for x1,y1,x2,y2 in lines[i]:

        L = (linelength(x1,y1,x2,y2))
        if L > max_length:
          max_length  = L
          max_p = [x1,y1,x2,y2]
          max_line_slope_sign = np.sign(lineSlope(max_p[0], max_p[1], max_p[2], max_p[3]))
          
  for i in range(len(lines)):
      for x1,y1,x2,y2 in lines[i]:
          sign_all_slopes = np.sign(lineSlope(x1,y1,x2,y2))

          if (sign_all_slopes == max_line_slope_sign): # if slope of any line has same size as that of the longest line then it is a solid line
            cv2.line( frame, (x1, y1), (x2,y2), (0,255,0),2)
          else:       
            cv2.line( frame, (x1, y1), (x2,y2), (0,0,255),2)   
          
  return frame

cap = cv2.VideoCapture('whiteline.mp4')
frame_width = int(cap.get(3))
frame_height = int(cap.get(4))

out = cv2.VideoWriter('lane_detec.avi',cv2.VideoWriter_fourcc('M','J','P','G'), 10, (frame_width,frame_height))
if (cap.isOpened()== False): 
  print("Error opening video stream or file")

while(cap.isOpened()):  
 
  ret, frame = cap.read()
  # frame = np.array(np.flip(frame, axis = 1)) # FOR FLIPPING THE FRAME                             
  if ret == True:

    gray_image = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY) # converts image into single channel
    gauss = cv2.GaussianBlur(gray_image, (5, 5), 0) # reduces noise

    width = cap.get(3)
    height = cap.get(4)

    triangular_region = [(0, height), (width / 2, (height / 2) + 30), (width, height)] # region of interest
    img_edge = cv2.Canny(gauss,100,200) # using canny edge detection
    cropped_img = image_cropping(img_edge, np.array([triangular_region], np.int32)) # cropping the image according to region of interest

    rho = 2 ## parameters for hough transform
    theta = np.pi/180   
    thresh = 100
    minLineLength = 20                         
    maxLineGap = 10                     

    lines = cv2.HoughLinesP( cropped_img, rho, theta, thresh, np.array([]), minLineLength, maxLineGap)           
    frame = dash_or_solid(lines) # classify lines as dashed or solid and return final image
    # out.write(frame) 

    cv2.imshow('Frame',frame)                 
    cv2.waitKey(0) # writing all the frames in a video

    if cv2.waitKey(0) & 0xFF == ord('q'):
      break             

  else:             
    break                             
  
cap.release()
out.release()
cv2.destroyAllWindows()